// Copyright 2022 Criticality Score Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// The scorer command is used for calculating the criticality score for signals
// generated by the collect_signals command.
//
// The scoring algorithm is defined by a YAML config file that defines the
// basic algorithm (e.g. "pike") and the fields to include in the score. Each
// field's upper and lower bounds, weight and distribution, and whether
// "smaller is better" can be set in the config.
//
// For example:
//
//	algorithm: pike
//	fields:
//	  legacy.created_since:
//	    weight: 1
//	    upper: 120
//	    distribution: zipfian
//
// The raw signals, along with the score, are returning in the output.
package main

import (
	"context"
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path"

	"github.com/urfave/cli/v2"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"

	"github.com/ossf/criticality_score/internal/infile"
	log "github.com/ossf/criticality_score/internal/log"
	"github.com/ossf/criticality_score/internal/outfile"
	"github.com/ossf/criticality_score/internal/scorer"
)

const (
	inFileFlag      = "in-file"
	outFileFlag     = "out-file"
	config          = "config"
	columnFlag      = "column"
	logFlag         = "log"
	logEnvFlag      = "log-env"
	defaultLogLevel = zapcore.InfoLevel
)

var (
	configFlag     = flag.String("config", "", "the filename of the config (required)")
	columnNameFlag = flag.String("column", "", "the name of the output column")
	logLevel       = defaultLogLevel
	logEnv         log.Env
)

func setUpCli() *cli.App {
	return &cli.App{
		Usage: "Scores collected signal for record in the IN_CSV.",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    config,
				Aliases: []string{"c"},
				Usage:   "the filename of the config, if none is provided, the default config is used",
			},
			&cli.StringFlag{
				Name:     columnFlag,
				Aliases:  []string{"n"},
				Usage:    "the name of the output column",
				Required: true,
			},
			&cli.IntFlag{
				Name:    logFlag,
				Aliases: []string{"l"},
				Usage:   "set the `level` of logging.",
				Value:   int(defaultLogLevel),
			},
			&cli.IntFlag{
				Name:    logEnvFlag,
				Aliases: []string{"e"},
				Usage:   "set logging `env`.",
				Value:   int(log.DefaultEnv),
			},
			&cli.StringFlag{
				Name:     outFileFlag,
				Aliases:  []string{"o"},
				Usage:    "the output file to write to",
				Required: true,
			},
			&cli.StringFlag{
				Name:     inFileFlag,
				Aliases:  []string{"i"},
				Usage:    "the input file to read from",
				Required: true,
			},
		},
		Before: func(c *cli.Context) error {
			// validate the in file
			if c.String(inFileFlag) == "" {
				return errors.New("in-file is required")
			}
			// validate the out file
			if c.String(outFileFlag) == "" {
				return errors.New("out-file is required")
			}
			// validate the column flag
			if c.String(columnFlag) == "" {
				return errors.New("column is required")
			}

			if _, err := os.Stat(c.String(inFileFlag)); !os.IsExist(err) {
				return fmt.Errorf("in-file %s does not exist", c.String(inFileFlag))
			}

			return nil
		},
	}
}

func init() {
	flag.Var(&logLevel, "log", "set the `level` of logging.")
	flag.TextVar(&logEnv, "log-env", log.DefaultEnv, "set logging `env`.")
	outfile.DefineFlags(flag.CommandLine, "out", "force", "append", "OUT_FILE") // TODO: add the ability to disable "append"
	flag.Usage = func() {
		cmdName := path.Base(os.Args[0])
		w := flag.CommandLine.Output()
		fmt.Fprintf(w, "Usage:\n  %s [FLAGS]... IN_CSV OUT_CSV\n\n", cmdName)
		fmt.Fprintf(w, "Scores collected signal for record in the IN_CSV.\n")
		fmt.Fprintf(w, "IN_CSV must be either a csv file or - to read from stdin.\n")
		fmt.Fprintf(w, "OUT_CSV must be either be a csv file or - to write to stdout.\n")
		fmt.Fprintf(w, "\nFlags:\n")
		flag.PrintDefaults()
	}
}

func generateColumnName(s *scorer.Scorer) string {
	if *columnNameFlag != "" {
		// If we have the column name, just use it as the name
		return *columnNameFlag
	}
	return s.Name()
}

func makeOutHeader(header []string, resultColumn string) ([]string, error) {
	for _, h := range header {
		if h == resultColumn {
			return nil, fmt.Errorf("header already contains field %s", resultColumn)
		}
	}
	return append(header, resultColumn), nil
}

func makeRecord(header, row []string) map[string]string {
	record := make(map[string]string)
	for i, k := range header {
		v := row[i]
		record[k] = v
	}
	return record
}

func main() {
	app := setUpCli()

	app.Action = func(c *cli.Context) error {
		logger, err := log.NewLogger(logEnv, logLevel)
		if err != nil {
			panic(err)
		}
		defer logger.Sync()

		inFilename := c.String(inFileFlag)

		if inFilename == "" {
			// This is for the condition that the user does not provide the in-file flag and instead uses the positional argument
			inFilename = c.Args().Get(0)
		}

		// Open the in-file for reading
		var r *csv.Reader
		fr, err := infile.Open(context.Background(), inFilename)
		if err != nil {
			logger.With(
				zap.Error(err),
				zap.String("filename", inFilename),
			).Error("Failed to open input file")
			return err
		}
		defer fr.Close()
		r = csv.NewReader(fr)

		// Open the out-file for writing
		fw, err := outfile.Open(context.Background())
		if err != nil {
			logger.With(
				zap.Error(err),
			).Error("Failed to open file for output")
			return err
		}
		defer fw.Close()
		w := csv.NewWriter(fw)
		defer w.Flush()

		var s *scorer.Scorer
		if *configFlag == "" {
			s = scorer.FromDefaultConfig()
		} else {
			// Prepare the scorer from the config file
			cf, err := os.Open(*configFlag)
			if err != nil {
				logger.With(
					zap.Error(err),
					zap.String("filename", *configFlag),
				).Error("Failed to open config file")
				return err
			}
			defer cf.Close()

			s, err = scorer.FromConfig(scorer.NameFromFilepath(*configFlag), cf)
			if err != nil {
				logger.With(
					zap.Error(err),
					zap.String("filename", *configFlag),
				).Error("Failed to initialize scorer")
				return err
			}
		}

		inHeader, err := header(r, logger, s, w)

		if err != nil {
			return err
		}

		err = pqStuff(r, logger, inHeader, s, w)

		if err != nil {
			return err
		}

		// -allow-score-override -- if the output field exists overwrite the existing data
		return nil
	}
}

func header(r *csv.Reader, logger *zap.Logger, s *scorer.Scorer, w *csv.Writer) ([]string, error) {
	inHeader, err := r.Read()
	if err != nil {
		logger.With(
			zap.Error(err),
		).Error("Failed to read CSV header row")
		return nil, err
	}

	// Generate and output the CSV header row
	outHeader, err := makeOutHeader(inHeader, generateColumnName(s))
	if err != nil {
		logger.With(
			zap.Error(err),
		).Error("Failed to generate output header row")
		return nil, err
	}
	if err := w.Write(outHeader); err != nil {
		logger.With(
			zap.Error(err),
		).Error("Failed to write CSV header row")
		return nil, err
	}
	return inHeader, nil
}

func pqStuff(r *csv.Reader, logger *zap.Logger, inHeader []string, s *scorer.Scorer, w *csv.Writer) error {
	var pq PriorityQueue
	for {
		row, err := r.Read()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			logger.With(
				zap.Error(err),
			).Error("Failed to read CSV row")
			return err
		}
		record := makeRecord(inHeader, row)
		score := s.ScoreRaw(record)
		row = append(row, fmt.Sprintf("%.5f", score))
		pq.PushRow(row, score)
	}

	// Iterate over the pq and send the results to the output csv.
	t := pq.Len()
	for i := 0; i < t; i++ {
		if err := w.Write(pq.PopRow()); err != nil {
			logger.With(
				zap.Error(err),
			).Error("Failed to write CSV header row")
			return err
		}
	}

	return nil
}
